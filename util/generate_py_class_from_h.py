# generate python class from c++ header file
import CppHeaderParser
import os



data_types = {'float':"ctypes.c_float", 'uint32_t':"ctypes.c_uint32", 'uint16_t':"ctypes.c_uint16", 'uint8_t':"ctypes.c_uint8",
              'int32_t':"ctypes.c_int32", 'int16_t':"ctypes.c_int16", 'int8_t':"ctypes.c_int8",
              'double':"ctypes.c_double", 'char':"ctypes.c_char", 'bool':"ctypes.c_bool",
              'uint64_t':"ctypes.c_uint64", 'int64_t':"ctypes.c_int64", 
              'int':"ctypes.c_int32", 'unsigned int':"ctypes.c_uint32",
              'long':"ctypes.c_int64", 'unsigned long':"ctypes.c_uint64",
              'UINT32':"ctypes.c_uint32", 'UINT16':"ctypes.c_uint16", 'UINT8':"ctypes.c_uint8",
              'FLOAT':"ctypes.c_float", 'DOUBLE':"ctypes.c_double", 'UINT64':"ctypes.c_uint64",
              "INT8":"ctypes.c_int8", "INT16":"ctypes.c_int16", "INT32":"ctypes.c_int32", "INT64":"ctypes.c_int64"}

def gen_class_ctypes(res_path, struct_info, pack=1):
    res_info = ''
    class_name = struct_info['name']
    res_info += f"class {class_name}(ctypes.Structure):\n"
    if pack != 0:
        res_info += f"    _pack_ = {pack}\n"
    res_info += f"    _fields_ = [\n"
    for field in struct_info['properties']['public']:
        field_name = field['name']
        field_type = field['type']
        if field_type in data_types:
            field_type = data_types[field_type]
        # process array
        if field['array']:
            if 'array_size' in field:
                field_type = f"{field_type} * {field['array_size']}"
            else:
                # field_type = f"{field_type} * {field['array']}"
                field_type = f"ctypes.c_byte * {field['array']}"
        res_info += f"        ('{field_name}', {field_type}),\n"
    res_info += f"    ]\n"
    res_info += f"\n"

    
    with open(res_path, "a") as f:
        f.write(res_info)

              

def gen_title(res_path):
    with open(res_path, "w") as f:
        f.write("#!/usr/bin/env python3\n")
        f.write("# -*- coding: utf-8 -*-\n")
        f.write("# Path: " + res_path + "\n")
        f.write("# This file is generated by gen_pyclass_from_h_file.py\n")
        f.write("# Do not modify this file manually\n")
        f.write("# Generate python class from c++ header file\n")
        f.write("import ctypes\n")
        f.write("\n")

# generate define parameters
def gen_define(res_path, cpp_header):
    res_info = ''
    for define in cpp_header.defines:
        define_info_list = define.replace("(", "").replace(")", "").split()
        if len(define_info_list) >= 2:
            define_name = define_info_list[0]
            # 策略
            define_value = define_info_list[1].replace("u", "")
            define_value = define_info_list[1].replace("UL", "")
            if "sizeof" in define_value:
                continue
            res_info += f"{define_name} = {define_value}\n"
    res_info += f"\n"
    with open(res_path, "a") as f:
        f.write(res_info)

def gen_all(res_path, header_file_path):
    gen_title(res_path)
    cpp_header = CppHeaderParser.CppHeader(header_file_path)
    gen_define(res_path, cpp_header)

    # get pack value
    pack = 0
    if cpp_header.pragmas:
        for pragma in cpp_header.pragmas:
            if pragma.find("pack") != -1:
                pack_num = pragma.replace("pack", "").replace("(", "").replace(")", "").strip()
                if pack_num.isdigit():
                    pack = int(pack_num)
                    break
    # h文件里的pack方法太复杂了,暂时直接设为1
    pack=1
    print("pack:", pack)
    # generate struct
    for c in cpp_header.classes:
        print(c)
        gen_class_ctypes(res_path, cpp_header.classes[c], pack=pack)
        print("=====================================")

if __name__ == "__main__":
    header_file_path = "protocol/sta775s_changan_x64.h"
    res_path = "sta775s_changan_x64.py"
    gen_all(res_path, header_file_path)